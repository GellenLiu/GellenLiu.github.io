(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b3460"],{2859:function(e,o){var p='<h2 id="1、vue框架的优点？">1、vue框架的优点？</h2> <p>vue是一个轻量级的渐进式框架，只关注视图层，易于上手。 优点主要有四个： 一个是，双向数据绑定，在数据操作方面比较简单。 一个是，组件化开发。 一个是，虚拟DOM。减少DOM操作的性能消耗 轻量高效。通过简洁的API提供高效的数据绑定和灵活的组件系统。</p> <p>缺点：不支持ie8.0及以下版本。</p> <h2 id="2、vue父组件向子组件传递数据？">2、vue父组件向子组件传递数据？</h2> <p>通过props传递，在父组件写。父组件冒号绑定数据。</p> <h2 id="3、子组件向父组件传递事件？">3、子组件向父组件传递事件？</h2> <p>$emit方法，子组件写emit方法，（‘事件名’，‘数据’），父组件用该子组件的标签时，@事件名，绑定触发的方法，获取数据。</p> <h2 id="4、v-show和v-if指令的共同点和不同点？">4、v-show和v-if指令的共同点和不同点？</h2> <p>都能控制元素的显示和隐藏，v-show控制css的display来控制显示和隐藏。v-if是动态对DOM操作，创建或销毁DOM元素 性能消耗比较大。</p> <p><strong>v-if = display:none + 干掉其Dom节点</strong>。</p> <h2 id="6的作用是什么">6.<keep-alive></keep-alive>的作用是什么?</h2> <p>答:keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p> <h2 id="7、vue如何获取dom元素？">7、vue如何获取DOM元素？</h2> <p>一个是通用的，document.getelementbyid。 一个是vue框架的ref属性，给相应的元素加ref=“name” 然后再this.$refs.name获取到该元素。</p> <h2 id="8说出几种vue当中的指令和它的用法？">8.说出几种vue当中的指令和它的用法？</h2> <p>答：v-model双向数据绑定； v-for循环； v-if v-show 显示与隐藏； v-on事件；v-once: 只绑定一次。</p> <h2 id="9vue-loader是什么？使用它的用途有哪些？">9.vue-loader是什么？使用它的用途有哪些？</h2> <p>答：vue文件的一个加载器，将template/js/style转换成js模块。</p> <h2 id="10为什么使用key">10.为什么使用key?</h2> <p>答：需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。 作用主要是为了高效的更新虚拟DOM。</p> <h2 id="11、虚拟dom和真实dom">11、虚拟DOM和真实DOM</h2> <p>渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据， 如果直接渲染到真实dom上会引起整个dom树的重绘和重排。 vue根据真实DOM生成一个虚拟DOM，<strong>真实DOM是树形结构，虚拟DOM是对象结构</strong></p> <h2 id="13axios及安装">13.axios及安装?</h2> <p>答：请求后台资源的模块。npm install axios --save装好。然后再main.js里面import一下，new vue里面引用一下。</p> <h2 id="mockjs">mock.js</h2> <p>仿接口，假数据，拦截请求，返回假数据</p> <h2 id="14、请说出vuecli项目中src目录每个文件夹和文件的用法？">14、请说出vue.cli项目中src目录每个文件夹和文件的用法？</h2> <p>答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置; app.vue是一个应用主组件；main.js是入口文件。</p> <h2 id="15分别简述computed和watch的使用场景">15.分别简述computed和watch的使用场景</h2> <p>答：computed: 　　　　当一个属性受多个属性影响的时候就需要用到computed watch: 　　　　当一条数据影响多条数据的时候就需要用watch</p> <h2 id="16v-on可以监听多个方法吗？">16.v-on可以监听多个方法吗？</h2> <p>答：可以，栗子：<input type="text" v-on="{ input:onInput,focus:onFocus,blur:onBlur, }">。 一个事件也可以触发多个方法，用逗号相隔。</p> <h2 id="17nexttick的使用">17.$nextTick的使用</h2> <p>在dom更新后执行</p> <p>答：当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值， 你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功。</p> <p>Vue 实现响应式并<strong>不是数据发生变化之后 DOM 立即变化</strong>，而是按一定的策略进行 DOM 的更新</p> <p>需要等到一个操作结束之后再进行下一个操作</p> <h2 id="18、对渐进式框架的理解">18、对渐进式框架的理解</h2> <p>主张最少；可以根据不同的需求选择不同的层级。</p> <p>想用什么就实现什么。</p> <h2 id="19、单页面应用和多页面应用区别及优缺点">19、单页面应用和多页面应用区别及优缺点</h2> <p><strong>单页面应用（SPA）</strong>，通俗一点说就是指只有一个主页面的应用，<strong>浏览器一开始要加载所有必须的 html, js, css</strong>。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。 <strong>多页面（MPA）</strong>，就是指一个应用中有多个页面，页面跳转时是整页刷新 单页面的优点： 用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。 单页面缺点： <strong>不利于seo</strong>；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p> <h2 id="21v-if和v-for的优先级">21.v-if和v-for的优先级</h2> <p>答：当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐v-if和v-for同时使用。</p> <p>vue3中v-if比v-for优先级高，所以用v-for的内容当v-if的条件的时候会报错。</p> <h2 id="22assets和static的区别"><strong>22.assets和static的区别</strong></h2> <p>答：<strong>相同点：</strong>assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点 <strong>不相同点</strong>：assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传至服务器。static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录</p> <h2 id="24vue的两个核心点">24.vue的两个核心点</h2> <p>答：数据驱动、组件系统 数据驱动：ViewModel，保证数据和视图的一致性。 组件系统：应用类UI可以看作全部是由组件树构成的。</p> <h2 id="25、data是函数">25、data是函数</h2> <p>组件中的<code>data</code>写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份<code>data</code>，就会造成一个变了全都会变的结果。</p> <h2 id="26、hash模式和history模式的不同">26、hash模式和history模式的不同</h2> <p>最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的</p> <p>对于vue这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— <strong>改变视图的同时不会向后端发出请求。</strong></p> <p>为了达到这一目的，浏览器当前提供了以下两种支持：</p> <p>hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：<a href="http://www.abc.com/#/hello">http://www.abc.com/#/hello</a> hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。 history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。 因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.</p> ';e.exports=p}}]);
//# sourceMappingURL=chunk-2d0b3460.bd6a4950.js.map