(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0e4a63"],{"90b8":function(n,o){var e='<h1 id="javascript学习笔记">JavaScript学习笔记</h1>\n<h2 id="数据类型">数据类型</h2>\n<p>Number</p>\n<p>String</p>\n<p>Boolean</p>\n<p>Undefined</p>\n<p>null</p>\n<p>symbol</p>\n<p>bigint</p>\n<p>Object</p>\n<p>Function</p>\n<p>Array</p>\n<h2 id="symbol有什么用">symbol有什么用</h2>\n<p>symbol是唯一的。表示唯一的值</p>\n<pre><code class="language-js">let mySymbol = Symbol();创建\n\nlet s1 = Symbol.for(&#39;foo&#39;); let s2 = Symbol.for(&#39;foo&#39;); s1 === s2 *// true*\n\n\nlet s1 = Symbol.for(&quot;foo&quot;);\nSymbol.keyFor(s1) // &quot;foo&quot;\n</code></pre>\n<p>Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。所以我们可以用Object.getOwnPropertySymbols方法，获取指定对象的所有 Symbol 属性名。</p>\n<pre><code class="language-js">如果两个操作数不是相同的类型，JavaScript转换\n操作数n适用严格的比较。如果任一操作数是数字\n或布尔值，则操作数将转换为数字（如果可能）; else\n如果任一操作数是字符串，则另一个操作数转换为\n字符串（如果可能）。如果两个操作数都是对象，则JavaScript\n比较内部引用，当操作数引用\n时内存中的相同对象时，内部引用相等\n</code></pre>\n<h2 id="typeof和instanceof的区别">typeof和instanceof的区别</h2>\n<p>typeof判断数据类型，返回类型</p>\n<p>“typeof”可以返回的数据类型有：“number”、“string”、“boolean”、“undefined”、“object”、“function”</p>\n<p>instanceof判断该对象是谁的示例，返回true或false,原型链上的都为true</p>\n<h2 id="简单请求和非简单请求">简单请求和非简单请求</h2>\n<p>只要同时满足以下两大条件，就属于简单请求。</p>\n<pre><code>（1) 请求方法是以下三种方法之一：\n    HEAD\n    GET\n    POST\n（2）HTTP的头信息不超出以下几种字段：   \n    Accept\n    Accept-Language\n    Content-Language\n    Last-Event-ID\n    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n</code></pre>\n<h2 id="head请求">HEAD请求</h2>\n<p>常常被忽略，但是能提供很多有用的信息，特别是在有限的速度和带宽下。主要有以下特点：\n1、只请求资源的首部；\n2、检查超链接的有效性；\n3、检查网页是否被修改；\n4、多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等</p>\n<p>于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。</p>\n<h2 id="option请求">Option请求</h2>\n<p>浏览器必须首先使用 OPTIONS 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p>\n<h2 id="1、字符串的不可变性">1、字符串的不可变性</h2>\n<p>eg. </p>\n<pre><code class="language-javascript">let str = &quot;abcd&quot;\nstr[0] = &#39;f&#39;\nconsole.log(str[0]);// 输出是a\n</code></pre>\n<p>不能改变单个字符的值，只能重新赋值整个字符串。</p>\n<h2 id="2、数组">2、数组</h2>\n<p>Array可以包含任意的数据类型</p>\n<pre><code class="language-javascript">let arr = [1,2,3,null,&#39;abc&#39;]\n</code></pre>\n<p>1、长度</p>\n<pre><code class="language-javascript">arr.length\n</code></pre>\n<p>2、indexOf，通过元素获得下标索引</p>\n<p>3、slice（）  截取Array的一部分，返回一个新的数组</p>\n<p>4、push,pop</p>\n<p>​\tpush;压入到尾部</p>\n<p>​\tpop弹出一个元素</p>\n<p>5、unshift（），shift（）</p>\n<p>​\tunshift压入到头部</p>\n<p>​\tshift弹出头部的一个元素</p>\n<p>6、sort（）排序</p>\n<p>7、元素反转reverse（）</p>\n<p>8、concat（）拼接数组，返回一个新是数组</p>\n<p>9、连接符join（）</p>\n<p>​\t打印拼接数组，使用特定的字符串连接</p>\n<pre><code class="language-javascript">let arr = [&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]\narr.join(&quot;-&quot;)\n&quot;c-b-a&quot;\n</code></pre>\n<p>10、多维数组</p>\n<pre><code class="language-javascript">let arr = [[1,2,3],[4,5,6]]\narr[0][1]// 2\n</code></pre>\n<h3 id="11、连接连个数组">11、连接连个数组</h3>\n<p>arr = [...arr1,...arr2]</p>\n<h2 id="22数组排序">2.2数组排序</h2>\n<pre><code>var points = [40, 100, 1, 5, 25, 10];\npoints.sort(function(a, b){return a - b}); \n需要重写sort的比值函数，不然会根据字符串来排序\n</code></pre>\n<h2 id="24数组去重">2.4数组去重</h2>\n<pre><code class="language-js">let a = Array.from(new Set(arr)\n</code></pre>\n<h2 id="3、对象">3、对象</h2>\n<pre><code class="language-javascript">// 定义了一个对象\nvar 对象名 = {\n    属性名： 属性值，\n    属性名： 属性值，\n    属性名： 属性值\n}\n</code></pre>\n<p>用{}包裹，键值对描述属性。</p>\n<p><strong>使用 prototype 属性就可以给对象的构造函数添加新的属性：</strong></p>\n<p>JavaScript中所有的键都是字符串，值是任意对象。</p>\n<h3 id="遍历对象">遍历对象</h3>\n<p>for(let item in obj)</p>\n<p>Object.keys主要用于遍历对象自有的可枚举属性，不包括继承自原型的属性和不可枚举的属性。</p>\n<h3 id="new做了什么">new做了什么</h3>\n<p>(1) 创建一个新对象；\n(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；\n(3) 执行构造函数中的代码（为这个新对象添加属性） ；\n(4) 返回新对象。</p>\n<pre><code class="language-js">function foo(a){\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log(bar.a); // 2\n// 其中 new foo(2) 进行的是类似如下的操作\n{\n    var obj = new Object();\n    obj.__proto__ = foo.prototype;\n    var result = foo.call(obj,&quot;2&quot;);\n    return result === &#39;object&#39; ? result : obj\n}\n</code></pre>\n<p>————————————————</p>\n<p><strong>一、构造函数法</strong></p>\n<p>这是经典方法，也是教科书必教的方法。它用构造函数模拟&quot;类&quot;，在其内部用this关键字指代实例对象。</p>\n<blockquote>\n<p>　　function Cat() {</p>\n<p>　　　　this.name = &quot;大毛&quot;;</p>\n<p>　　}</p>\n</blockquote>\n<p>生成实例的时候，使用new关键字。</p>\n<blockquote>\n<p>　　var cat1 = new Cat();</p>\n<p>　　alert(cat1.name); // 大毛</p>\n</blockquote>\n<p>类的属性和方法，还可以定义在构造函数的prototype对象之上。</p>\n<blockquote>\n<p>　　Cat.prototype.makeSound = function(){</p>\n<p>　　　　alert(&quot;喵喵喵&quot;);</p>\n<p>　　}</p>\n</blockquote>\n<p>二、</p>\n<blockquote>\n<p>　　var Cat = {</p>\n<p>　　　　name: &quot;大毛&quot;,</p>\n<p>　　　　makeSound: function(){ alert(&quot;喵喵喵&quot;); }</p>\n<p>　　};</p>\n</blockquote>\n<p>然后，直接用Object.create()生成实例，不需要用到new。</p>\n<blockquote>\n<p>　　var cat1 = Object.create(Cat);</p>\n</blockquote>\n<p>1、使用一个不存在的对象属性，不会报错！ undefined而已</p>\n<p>2、动态的删减属性(delete删除属性)</p>\n<pre><code class="language-javascript">delete person.name\n</code></pre>\n<p>3、动态的添加(直接给新属性添加值)</p>\n<pre><code class="language-javascript">person.haha = &quot;hello&quot;\n</code></pre>\n<p>4、判断属性值是否在这个对象中</p>\n<pre><code class="language-javascript">&#39;haha&#39; in person\ntrue\n// 继承\n&#39;toString&#39; in person\ntrue\n</code></pre>\n<p>5、判断一个属性是否是对象自身的</p>\n<pre><code class="language-javascript">person.hasOwnProperty(&#39;toString&#39;)\nfalse\nperson.hasOwnProperty(&#39;haha&#39;)\ntrue\n</code></pre>\n<h3 id="用prototype和不用的区别">用prototype和不用的区别</h3>\n<p>prototype是原型对象，也就是类，在类上添加</p>\n<p><strong>给类定义一个属性：</strong></p>\n<p>在函数里面就用this，在函数外面，用函数名.prototype.xxx;</p>\n<pre><code class="language-js">首先来看一个实例：\nfunction ListCommon2(first,second,third) \n{ \n    this.First=function () \n    { \n        alert(&quot;first do&quot;+first); \n    } \n} \n//不加prototype的情况\nListCommon2.do1=function(first) \n{ \n    // this.First(); \n    alert(&quot;first do&quot;+first); \n} \n//添加prototype的情况\nListCommon2.prototype.do2=function(first) \n{ \n    // this.First(); \n    alert(&quot;first do&quot;+first); \n} \n\n上面添加与不添加prototype有什么区别呢？下面我们来测试这个实例。代码如下：\n\nvar t1=new ListCommon2(&quot;烧水1&quot;,&quot;泡茶1&quot;,&quot;喝1&quot;); \n// t1.do1();//调用出错 \nListCommon2.do1(&quot;烧水1&quot;); \nvar t2=new ListCommon2(&quot;烧水2&quot;,&quot;泡茶2&quot;,&quot;喝2&quot;); \nt2.do2(&quot;烧水2&quot;);// \n// ListCommon2.do2(&quot;烧水1&quot;);//调用出错 \n\n//property将属性加到构造函数里面，不加property的话新建对象无关\n</code></pre>\n<h2 id="回调函数">回调函数</h2>\n<p>将一个函数作为参数传递到另一个函数中执行，传入的函数参数就叫回调函数</p>\n<p>用setInterval来一直异步运行</p>\n<pre><code class="language-js">// 倒计时启动和关闭回调封装\n    setCountDownTime(callback) {\n      if (this.countDownTime &gt; 0) {\n        this.countDownInterval = setInterval(() =&gt; {\n          if (this.countDownTime &gt;= 1) {\n            this.countDownTime -= 1;\n            this.joinEndStr = this.countDownTimeStr(this.countDownTime);\n          } else {\n            clearInterval(this.countDownInterval);\n            // 倒计时为0 刷新比赛进程，自动开赛\n            callback();\n          }\n        }, 1000);\n      }\n    },\n</code></pre>\n<h2 id="4、流程控制">4、流程控制</h2>\n<h3 id="1、if-else判断">1、if-else判断</h3>\n<h3 id="2、while循环">2、while循环</h3>\n<pre><code class="language-javascript">while(age&lt;100){\n    age = age +1;\n    console.log(age)\n}\n</code></pre>\n<h3 id="3、for循环">3、for循环</h3>\n<pre><code class="language-javascript">for(let i = 0;i&lt;100;i++){\n    console.log(i)\n}\n</code></pre>\n<h3 id="4、foreach循环es51">4、forEach循环(ES5.1)</h3>\n<pre><code class="language-javascript">var age = [1,2,3,4,5]\nage.forEach(function(value){\n    console.log(value)\n})\n</code></pre>\n<h3 id="5、forin遍历forofes6">5、for...in遍历/for...of(ES6)</h3>\n<pre><code class="language-javascript">for(var num in age){\n    // num是索引\n    console.log(age[num])\n}\nfor(var num of age){\n    // num是值\n    console.log(num)\n}\n</code></pre>\n<h3 id="5、map和set（es6新特性）">5、Map和Set（ES6新特性）</h3>\n<pre><code class="language-javascript">// 取值\nvar map = new Map([&#39;tom&#39;,100],[&#39;jack&#39;,90])\nvar name = map.get(&#39;tom&#39;)\nconsole.log(name)//获得100\n\n//设值\nmap.set(&#39;admin&#39;,100);\nmap.delete(&#39;tom&#39;)\nmap.has(&#39;&#39;)\n\n//遍历map\nfor....of..\n\n\n//map排序\nlet arr = Array.from(map)\narr.sort(function(a,b){return a[1]-b[1]})\n</code></pre>\n<p>Set:无序不重复的集合</p>\n<p>(可以去重复值)</p>\n<pre><code class="language-javascript">var set = new Set([3,2,2,2])\nset.delete(2)\nset.add(1)\n//是否有这个元素\nconsole.log(set.has(3))\n\n//遍历\nfor...of\n</code></pre>\n<h2 id="5、函数">5、函数</h2>\n<p>方法：对象（属性，方法）</p>\n<p>函数：不属于对象</p>\n<h3 id="51定义函数">5.1定义函数</h3>\n<blockquote>\n<p>定义方式一 </p>\n</blockquote>\n<pre><code class="language-javascript">function abs(x){\n    if(x&gt;=0){\n        return x;    \n    }else{\n        return -x;\n    }\n}\n</code></pre>\n<p>如果没有执行return，函数执行完也会返回结果，结果就是undefined</p>\n<blockquote>\n<p>定义方式二</p>\n</blockquote>\n<p>把函数赋值给对象，对象就成函数了。</p>\n<pre><code class="language-javascript">var abs = function(x){\n\n}\n</code></pre>\n<p>不存在参数如何规避？</p>\n<pre><code class="language-javascript">// 手动抛出异常\nif(typeof x!==&#39;number&#39;){\n    throw &#39;Not a Number&#39;\n}\n</code></pre>\n<blockquote>\n<p>arguments</p>\n</blockquote>\n<p>arguments 是一个关键字</p>\n<p>代表传递进来的所有参数是一个数组。</p>\n<p>即使你只定义了一个参数，但是你传入多个参数，可以用arguments来获取。</p>\n<blockquote>\n<p><strong>...rest</strong></p>\n</blockquote>\n<p>ES6新特性，获取除了已经定义的参数之外的参数。</p>\n<pre><code class="language-javascript">function fun(a,b,c,...rest){\n    console.log(rest)\n}\n</code></pre>\n<h3 id="52、变量的作用域">5.2、变量的作用域</h3>\n<p>var定义的变量实际是有作用域的。</p>\n<p>在函数内声明，则在函数体外不可以使用。（闭包可实现）</p>\n<blockquote>\n<p>内部函数可以访问外部函数的成员，反之则不行。</p>\n</blockquote>\n<p>假如，内部函数变量和外部函数的变量重名，则用内部的。从内往外找。</p>\n<h3 id="53提升变量的作用域">5.3提升变量的作用域</h3>\n<pre><code class="language-javascript">function a(){\n    var x = &#39;x&#39;+y;\n    console.log(x);\n    var y =&#39;y&#39;;\n}\n//结果：输出xundefined\n//结论：js执行引擎，自动提示了y的声明，但不会提升y的赋值。\n</code></pre>\n<p>变量的定义都写在前面。</p>\n<p>//var x,y,z...</p>\n<h3 id="54全局变量">5.4全局变量</h3>\n<p>在外部定义。</p>\n<p>全局对象window。</p>\n<p>默认所有的全局变量都绑定在window对象下。</p>\n<p>alert()也是window下的变量。</p>\n<p>方法也是变量，也是可以赋值的。</p>\n<p>js只有一个全局作用域，就是window。</p>\n<h3 id="55规范">5.5规范</h3>\n<p>由于所有的全局变量都会绑定到window上，如果使用了不同的js文件，使用了相同的全局变量，就会冲突。</p>\n<p>如何减少冲突？</p>\n<pre><code class="language-javascript">//唯一全局变量\nvar a = {}；\n\n//定义全局变量\na.name = &quot;jadfa&quot;;\na.add = function(a,b){\n    return a+b;\n}\n</code></pre>\n<p>把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突。</p>\n<blockquote>\n<p>局部作用域let</p>\n</blockquote>\n<p>ES6引入，解决局部作用域冲突问题。</p>\n<p>{}里面，一个作用域。</p>\n<blockquote>\n<p>常量const</p>\n</blockquote>\n<p>ES6之前，只要是全部使用大写字母定义的变量就认为是常量，不要去动它。</p>\n<p>ES6后用const定义。只读。</p>\n<h3 id="56方法">5.6方法</h3>\n<p>方法就是把函数方到对象里面。</p>\n<p>方法调用一定要带（）</p>\n<p>this。代表调用它的人。</p>\n<blockquote>\n<p>apply</p>\n</blockquote>\n<p>在js中可以控制this的指向</p>\n<pre><code class="language-javascript">getAge.apply(对象，[]);//this指向了指定对象\n</code></pre>\n<h2 id="6、内部对象">6、内部对象</h2>\n<blockquote>\n<p>标准对象</p>\n</blockquote>\n<pre><code class="language-javascript">typeof 123\n&quot;number&quot;\n\ntypeof &#39;123&#39;\n&quot;string&quot;\n\ntypeof []\n&quot;object&quot;\n\ntypeof NaN\n&quot;number&quot;\n\ntypeof Math.abs\n&quot;function&quot;\n\ntypeof true \n&quot;boolean&quot;\n\ntypeof undefined\n&quot;undefined&quot;\n</code></pre>\n<h3 id="61、date">6.1、Date</h3>\n<pre><code class="language-javascript">var now = new Date();\nnow.getFullYear();//年\nnow.getMonth();//0-11\nnow.getDate();//日\nnow.getDay();//星期几\nnow.getHours();//时\nnow.getMinuters();//分\nnow.getSeconds();//秒\n\nnow.getTime();//时间戳，距离1970.。\n\n</code></pre>\n<h3 id="62、json">6.2、JSON</h3>\n<p>轻量级的数据交换格式。</p>\n<p>在javascript中一切皆为对象，任何js支持的类型都可以用JSON来表示。</p>\n<blockquote>\n<p>格式</p>\n</blockquote>\n<p>对象都用{}</p>\n<p>数组都用[]</p>\n<p>键值对key：value</p>\n<h3 id="对象转换json字符串">对象转换JSON字符串</h3>\n<p>JSON.stringify()</p>\n<h3 id="json字符串解析成对象">JSON字符串解析成对象</h3>\n<p>JSON.parse()</p>\n<blockquote>\n<p>JSON和JS对象的区别</p>\n</blockquote>\n<pre><code class="language-javascript">var obj = {a: &#39;hello&#39;,b: &#39;ji&#39;}\nvar json = &#39;{&quot;a&quot;: &quot;hello&quot;,&quot;b&quot;: &quot;ji&quot;}&#39;\n</code></pre>\n<h2 id="7、面向对象编程">7、面向对象编程</h2>\n<h3 id="71、proto继承原型对象">7.1、proto继承原型对象</h3>\n<pre><code class="language-javascript">var Student = {\n    name: &quot;liuguo&quot;,\n    age: 3,\n    run: function(){\n        console.log(&quot;run...&quot;)\n    }\n}\nvar xiaoming = {\n    name: &quot;xiaoming&quot;\n};\n//继承\nxiaoming.__proto__ = Student;\n</code></pre>\n<h3 id="72、class继承">7.2、class继承</h3>\n<p>ES6引入class关键字</p>\n<p>1、定义一个类，属性，方法</p>\n<pre><code class="language-javascript">class Studnet{\n    constructor(name){\n        this.name = name;\n    }\n    hello(){\n        alter(&#39;hello&#39;)\n    }\n}\nvar xiaoming = new Student(&quot;xiaoming&quot;)\n</code></pre>\n<p>2、继承</p>\n<pre><code class="language-javascript">class XiaoStudent extends Student{\n    construtor(name,grade){\n        super(name);\n        this.grade = grade;\n    }\n    myGrade(){\n        console.log(&quot;adfaf&quot;)\n    }\n}\n</code></pre>\n<p>class的本质还是__proto__，只是为了更方便书写。</p>\n<blockquote>\n<p>原型链</p>\n</blockquote>\n<p>无限继承</p>\n<h2 id="、、定义类">、、定义类</h2>\n<p>class Point {</p>\n<p> constructor(x, y) {</p>\n<p>  this.x = x;</p>\n<p>  this.y = y;</p>\n<p> }</p>\n<p> toString() {</p>\n<p>  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</p>\n<p> }</p>\n<p>}</p>\n<p>与下列方式等价</p>\n<p>function Point(x, y) {</p>\n<p> this.x = x;</p>\n<p> this.y = y;</p>\n<p>}</p>\n<p>Point.prototype.toString = function () {</p>\n<p> return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</p>\n<p>};</p>\n<h2 id="8、操作bom对象">8、操作BOM对象</h2>\n<p>BOM：浏览器对象模型</p>\n<p>window代表浏览器窗口</p>\n<p>navigator：封装了浏览器的 信息</p>\n<p>screen：屏幕width，height</p>\n<blockquote>\n<p>location：当前页面的url信息</p>\n</blockquote>\n<p>reload()//刷新网页</p>\n<p>assign（）//设置新的地址</p>\n<blockquote>\n<p>document</p>\n</blockquote>\n<p>代表当前的页面</p>\n<p>获取文档节点document.getElementById()</p>\n<blockquote>\n<p>获取cookir </p>\n</blockquote>\n<p>document.cookie</p>\n<blockquote>\n<p>history</p>\n</blockquote>\n<p>history.back()//后退</p>\n<p>history.forward()//前进</p>\n<h2 id="9、操作dom对象">9、操作DOM对象</h2>\n<blockquote>\n<h3 id="更新：更新dom节点">更新：更新DOM节点</h3>\n</blockquote>\n<p>node.innerText</p>\n<p>node.innerHTML</p>\n<p>node.style.</p>\n<blockquote>\n<h3 id="遍历dom节点：得到节点">遍历DOM节点：得到节点</h3>\n</blockquote>\n<p>要操作一个DOM节点，就必须先获得这个节点。</p>\n<blockquote>\n<h3 id="删除一个dom节点">删除一个DOM节点</h3>\n</blockquote>\n<p>先获取父节点，再通过父节点删除自己。</p>\n<pre><code class="language-javascript">var father = p1.parentElement\nfather.removeChild(p1)\n\nfather.removeChild(father.children[0])\n</code></pre>\n<blockquote>\n<h3 id="添加一个新的节点">添加一个新的节点</h3>\n</blockquote>\n<p>innerHTML//会覆盖</p>\n<pre><code class="language-javascript">var newp =  document.createElement(&#39;p&#39;)\nnewp.id = &#39;newp&#39;\nnwep.innerText = &quot;helloworld&quot;\n\nnewp.setAttribute(&#39;&#39;,&#39;&#39;)\n\nnode.appendChild(newp);\n</code></pre>\n<h2 id="10、jquery">10、JQuery</h2>\n<p>里面存在大量的javascript函数</p>\n<script >标签引入\n​    公式:  $(selector).action()\n\n$代表JQuery\n\nselector就是**css的选择器**\n\n```javascript\n//选中标签,进行函数操作\n\n$(\'#id\').click(function(){\n    console.log("afs")\n})\n```\n\n\n\n> 事件\n\nmousedown()\n\nmouseover()\n\n等等\n\n## 11、闭包\n\n闭包就是嵌套函数，内部的函数可以访问外部函数的作用域。\n\n![img](https://img2018.cnblogs.com/blog/551750/201812/551750-20181212101629347-1385426172.jpg)\n\n**一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1=function(){var n = 0 ... }，并且匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的，所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里就产生了内存消耗的问题**\n\n作用：\n\n1. 可以在函数的外部访问到函数内部的局部变量。 \n2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。\n\n\n\n但我们可以使用闭包来模拟私有方法\n\n如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包**在处理速度和内存消耗方面对脚本性能具有负面影响。**\n\n\n\n### 12、第 31 题：下面代码输出什么\n\n```text\nvar a = 10;(function () {\nconsole.log(a)\na = 5\nconsole.log(window.a)\nvar a = 20;\nconsole.log(a)})()\n分别为 undefined 10 20，原因是作用域问题，在内部声名 var a = 20;相当于\n先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果\n把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值\n了。结果Ａ会是 10 5 5\n```\n\n\n\n## js代码规范\n\n```js\n   /**\n   * 查询段位排行榜\n   * @param {boolean} showLoading 是否显示加载中\n   * @returns {void}\n   */\n  queryRankList: function(showLoading = false) {\n    console.log("查询同店排行榜")\n    if (this.data.isLoading || !this.data.hasMore) {\n        \n        /**\n        * xsklfjal\n        * @param {string}\n        * @returns {number}\n        */\n         if (wincnt == 0 && losecnt == 0) {\n                res.playlist[i][\'winrate\'] = 0\n              } else {\n                res.playlist[i][\'winrate\'] = (wincnt * 100 / (wincnt + losecnt)).toFixed(1)\n              }\n        \n```\n\n运算符两边空格，函数右边括号后留空格，if后接空格\n\n测试用例\n\n\n\n## clientwidth和offsettop\n\n网页可见区域高：document.body.clientHeight\n\n网页正文全文高：document.body.scrollHeight\n网页可见区域高（包括边线的高）：document.body.offsetHeight\n网页被卷去的高：document.body.scrollTop\n\n屏幕分辨率高：window.screen.height\n\noffsettop： 顶部距离设置了position父元素的距离\n\n\n\n## 小程序setData注意事件\n\n1. 频繁的去 setData\n\n在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：\n\nAndroid 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；\n\n渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；\n\n\\2. 每次 setData 都传递大量新数据\n\n由setData的底层实现可知，我们的数据传输实际是一次 `evaluateJavascript` 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程，\n\n\\3. 后台态页面进行 setData\n\n当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。\n\n\n\n## js都是值传递，没有引用传递\n\n```js\n\n1 function setName(obj) {\n2     obj.name = "Nicholas";\n3     obj = new Object(); //改变obj的指向，此时obj指向一个新的内存地址，不再和person指向同一个\n4     obj.name = "Greg";\n5 }\n6 \n7 var person = new Object();\n8 setName(person);  //你看看下面，相信我也是按值传递的了吧\n9 alert(person.name);  //"Nicholas"\n\n传递的是指针的地址，内部新建了一个指向同一个地址的对象，所以看起来像是引用传递\n```\n';n.exports=e}}]);
//# sourceMappingURL=chunk-2d0e4a63.6d9c20b3.js.map